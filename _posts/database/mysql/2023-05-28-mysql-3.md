---
layout: post
title: Real MySQL 8.0 (3) - 아키텍처
date: 2023-05-28
categories: [database, mysql]
tags: [database, mysql]
---
# Real MySQL 8.0 8.0 (3) - 아키텍처
- MySQL 서버는 사람의 머리 역할의 MySQL 엔진과 손발 역할의 스토리지 엔진으로 구분
- 스토리지 엔진의 경우 핸들러 API를 만족하면 누구든지 스토리지 엔진을 구현해 MySQL 서버에 추가해서 사용 가능
- 기본제공되는 스토리지 엔진
  - InnoDB
  - MyISAM

***
## MySQL 엔진 아키텍처
MySQL 서버는 다른 DBMS에 비해 구조가 독특해 다른 DBMS에는 없는 혜택을 누릴 수 있으며, 반대로 다른 DBMS에서는 문제되지 않을 것들이 문제될 때가 있다. 크게 MySQL 엔진과 스토리지 엔진으로 구분한다

### MySQL 엔진
- 커넥션 핸들러
- SQL 인터페이스
- SQL 파서, 전처리기
- SQL 옵티마이저
- 캐시 & 버퍼

### 스토리지 엔진
- InnoDB or MyISAM
- Memory

실제 데이터를 디스크 스토리지에 저장하거나 읽어오는 부분을 전담

MySQL 서버에 MySQL 엔진은 하나지만, 스토리지 엔진은 여러 개를 동시에 사용 가능
```mysql
CREATE TABLE table_name (col1 INT, col2 INT) ENGINE=INNODB;
```
위와 같이 지정하면 SELECT, INSERT, DELETE, UPDATE 등의 작업 시 InnoDB 스토리지 엔진이 처리를 담당

각 스토리지 엔진은 성능 향상을 위해 키 캐시(MyISAM)나 InnoDB 버퍼 풀(InnoDB) 같은 기능을 내장

### 핸들러 API
- 핸들러(Handler) 요청에 사용되는 API
- 핸들러 요청
  - MySQL 엔진이 쿼리 실행기에서 데이터를 쓰거나 읽을 떄, 각 스토리지 엔진에 쓰기 또는 읽기를 요청하는 것
- InnoDB 스토리지 엔진도 핸들러 API를 사용해 MySQL 엔진과 데이터를 주고 받는다.
- 핸들러 API를 통해 얼마나 많은 데이터(레코드) 작업이 있는 지 확인
  - `SHOW GLOBAL STATUS LIKE 'Handler%';`

### MySQL 스레딩 구조
- MySQL 서버는 프로세스 기반이 아닌 스레드 기반
- 크게 Foreground thread와 Background thread로 구분
- `performance_schema.threads table`
<img src="performance_schema.threads.png">
- `thread/sql/one_connection` 스레드만 실제 사용자의 요청을 처리하는 Foreground threads
- background threads의 개수는 MySQL 서버 설정에 따라 달라질 수 있다.
- 동일한 이름의 스레드가 2개 이상씩 보이는 것은 MySQL 서버의 설정 내용에 의해 여러 스레드가 동일 작업을 병렬로 처리하는 경우
- MySQL의 커뮤니티 에디션
  - 전통적인 스레드 모델 사용 가능 
- MySQL의 엔터프라이즈 에디션과 Percona MySQL
  - 전통적인 스레드 모델 사용 가능
  - 스레드 풀(thead pool) 모델 사용 가능
- 전통적인 스레드 모델과 스레드 풀의 가장 큰 차이점은 Foreground thread와 connection의 관계
  - 전통적인 스레드 모델: Foreground thread와 connection이 1대1 관계(connection 별로 Foreground thread 생성)
  - 스레드 풀 모델: 하나의 스레드가 여러 개의 커넥션 요청을 전담

#### Foreground thread(client thread)
- Foreground thread의 최소 개수는 MySQL 서버에 접속된 클라이언트의 수
- 주로 각 클라이언트가 요청하는 쿼리 문장을 처리
- 클라이언트가 작업을 마치고 커넥션을 종료하면 담당 스레드는 스레드 캐시(thread cache)로 되돌아감
- 스레드 캐시에 일정 개수 이상의 대기 스레드가 있으면 스레드 캐시에 넣지 않고 스레드를 종료
- 스레드 캐시에 유지할 수 있는 최대 스레드 수: `thread_cache_size` 시스템 변수
- read
  1. 데이터를 MySQL 데이터 버퍼나 캐시에서 조회
  2. 없으면 디스크의 데이터나 인덱스 파일로부터 조회
- write
  - MyISAM의 경우, 디스크 쓰기 작업까지 Foreground thread가 처리
  - InnoDB의 경우, 데이터 버퍼나 캐시까지만 Foreground thread가 처리 / 버퍼부터 디스크까지는 Background thread가 처리

#### Background thread
보통은 InnoDB의 Background thread가 진행하는 작업
- 인서트 버퍼를 병합하는 스레드
- 로그를 디스크로 기록하는 스레드
- InnoDB 버퍼 풀의 데이터를 디스크에 기록하는 스레드
- 데이터를 버퍼로 읽어오는 스레드
- 잠금이나 데드락을 모니터링하는 스레드

5.5부터 데이터 쓰기 스레드와 읽기 스레드의 개수를 2개 이상 지정 가능(시스템 변수)
- `innodb_write_io_threads`
- `innodb_read_io_threads`
- InnoDB도 데이터 read는 주로 foreground thread에서 처리하기 때문에, read thread를 많이 설정할 필요 없다.
- write thread는 아주 많은 작업을 백그라운드로 처리하기 때문에, 일반적으로 내장 디스크를 사용할 때는 2~4 정도 설정(스토리지에 따라 최적화 필요)

**버퍼링**
- 쓰기 작업은 지연(버퍼링)되어 처리 가능
- 읽기 작업은 지연 불가능
- InnoDB는 쓰기작업을 버퍼링해서 일괄 처리
  - INSERT, UPDATE, DELETE 시, 데이터가 디스크의 파일로 완전히 저장될 때까지 기다리지 않아도 된다.
- MyISAM은 client thread가 쓰기까지 처리
  - 쓰기 버퍼링 사용 불가

### 메모리 할당 및 사용 구조
- 운영체제의 복잡한 할당 방식으로 할당
- 단순하게 MySQL의 시스템 변수로 설정해둔 만큼 할당 받는다고 생각
- MySQL 서버
  - 글로벌 메모리 영역
    - 클라이언트의 수와는 무관
    - 필요에 따라 N개 할당 가능(일반적으로 1개)
    - N개더라도 모든 스레드에 의해 공유
    - 종류
      - InnoDB 버퍼 풀
      - MyISAM 키 캐시
      - 바이너리 로그 버퍼
      - 리두 로그 버퍼
      - 테이블 캐시
  - 세션(커넥션, 로컬) 메모리 영역
    - 클라이언트 스레드가 쿼리를 처리하는 데 사용하는 메모리 영역
    - 커넥션당 생성되는 스레드가 사용하는 영역
    - 스레드간 독립적, 비공유
    - 커넥션이 열려있는 동안 계속 할당되어 있는 공간(커넥션 버퍼, 결과 버퍼)
    - 쿼리를 실행하는 순간에만 할당했다가 다시 해제하는 공간(소트 버퍼, 조인 버퍼)
      - 조인 버퍼
      - 정렬(sort) 버퍼
      - 네트워크 버퍼
      - 리드 버퍼

### 플러그인 스토리지 엔진 모델
- 스토리지 엔진, 사용자 인증 등
- `SHOW ENGINES;`, `SHOW PLUGINS` 명령어로 확인 가능

**MySQL에서 쿼리가 실행되는 과정**
    
MySQL 엔진(SQL parser -> SQL Optimizer -> SQL executor) -> <br>
스토리지 엔진(데이터 읽기/쓰기) -> <br>
디스크

=> 실질적인 `GROUP BY`나 `ORDER BY`는 MySQL 엔진의 처리 영역인 쿼리 실행기에서 처리

**핸들러**
MySQL 엔진이 스토리지 엔진에게 명령하려면 핸들러를 통해야만 한다.

### 컴포넌트
- 기존의 플러그인 아키텍처를 대체하기 위해 8.0부터 지원되는 컴포넌트 아키텍처
- 비밀번호 검증 기능은 5.7까지는 플러그인으로 지원되고, 8.0부터는 컴포넌트로 개선

**플러그인의 단점**
- 플러그인은 오직 MySQL 서버와 인터페이스 가능(플러그인간 통신 불가능)
- 플러그인은 MySQL 서버의 변수나 함수를 직접 호출(캡슐화x, 안전하지 않음)
- 플러그인은 상호 의존 관계를 설정할 수 없어 초기화가 어려움

### 쿼리 실행 구조

#### 쿼리 파서
- 요청으로 들어온 쿼리 문장을 토큰(MySQL이 인식할 수 있는 최소 단위나 어휘)으로 분리하고 트리 구조로 생성
- 기본 문법 오류 검출 및 오료 메시지 전달

#### 전처리기
- 파서 트리를 기반으로 구조적 문제점 확인
- 테이블 이름, 컬럼 이름, 내장 함수와 같은 개체를 매핑
- 해당 객체의 존재 여부와 접근 권한 확인

#### 옵티마이저
- DBMS의 두뇌
- 사용자 요청으로 들어온 쿼리 분장을 저렴한 비용으로 빠르게 처리할 지 결정

#### 실행 엔진
- 핸들러와 함께 손과 발 역할
- 옵티마이저가 결정한 내용을 핸들러들에게 명령(중간 관리자급)

#### 핸들러(스토리지 엔진)
- 실행 엔진의 요청에 따라 데이터를 디스크로 저장, 디스크로부터 읽어 오는 역할
- 스토리지 엔진을 의미

### 복제
나중에 다룸

### 쿼리 캐시
- 8.0부터 사라짐
- SQL 실행 결과를 메모리에 캐시, 동일 SQL이 실행되면 테이블을 읽지 않고 즉시 결과 반환
- 데이터가 변경되면 관련된 캐시는 전부 삭제 필요
- 심각한 동시 처리 성능 저하 유발
- 데이터가 변경이 거의 없는 서비스에서는 좋겠지만 그런 경우는 거의 없다.

### 스레드 풀
- 엔터프라이즈 버전에서 지원
- 커뮤니티 버전에서 사용하기 위해서는 Percona Server에서 제공하는 스레드 풀 사용

### 트랜잭션 지원 메타데이터
- 5.7까지는 테이블의 구조는 FRM 파일, 스토어드 프로그램은 (.TRN, .TRG .PAR ...) 파일에 저장
  - 파일 기반의 메타데이터는 트랜잭션을 지원하지 않기 때문에 MySQL 서버의 비정상적 종료가 발생하면 일관되지 않는 상태로 남게 됨(데이터베이스나 테이블이 깨졌다고 표현) 
- 8.0부터는 InnoDB 테이블에 저장(시스템 테이블)
  - 데이터 딕셔너리 정보들은 모두 mysql DB에 저장(mysql.ibd)
  - 디렉토리에 존재하는 위 파일은 특별히 조심
  - mysql table은 접근 권한이 없어 볼 수 없다.(실제로는 존재)
  - `information_schema`를 보면 데이터 딕셔너리에 대한 정보를 얻을 수 있다.
    - `SHOW CREATE TABLE INFORMATION_SCHEMA.TABLES;`
    - 뷰로 생성되어 있고, 이 뷰는 mysql db를 참조하고 있다.
  - MySQL 서버의 비정상 종료에도 완전한 성공 또는 완전한 실패로 정리
  - MyISAM이나 CSV 같은 스토리지 엔진은 여전히 메타 정보를 파일로 저장해야 한다.
  - 기존의 FRM 파일과 동일한 역할의 .sdi 파일이 존재
**데이터 딕셔너리 또는 메타데이터**
- 테이블의 구조 정보와 스토어드 프로그램 등의 정보

***
## InnoDB 스토리지 엔진 아키텍처
- MySQL에서 사용할 수 있는 스토리지 엔진 중 거의 유일하게 레코드 기반의 잠금을 제공
- 따라서 높은 동시성 처리가 가능하고 안정적이며 성능이 훌륭

### 프라이머리 키에 의한 클러스터링
- primary key를 기눚으로 클러스터링되어 저장
- 키 값의 순서대로 디스크에 저장
- secondary index는 레코드의 주소가 아닌 primary key를 논리적 주소로 사용
- primary key를 이용한 range scan은 상당히 빠르기 때문에, 쿼리의 실행 계획에서 primary key는 다른 보조 인덱스에 비해 비중이 높게 설정
- oracle의 IOT(Index Organized Table)와 동일한 구조가 InnoDB의 일반적인 테이블 구조

#### vs MyISAM
- MyISAM은 클러스터링 키 미지원
- MyISAM은 primary key와 secondary index가 구조적으로 같다. primary key는 unique 제약을 가진 secondary index
- MyISAM 테이블의 모든 인덱스는 물리적인 레코드의 주소 값(ROWID)을 가진다.

### 외래 키 지원
- InnoDB 스토리지 엔진 레벨에서 지원하는 기능으로 MyISAM 이나 MEMORY 테이블에서는 사용 불가
- InnoDB에서 외래 키는 부모 테이블과 자식 테이블 모두 해당 칼럼에 인덱스 생성이 필요
- 변경 시에는 반드시 부모-자식 데이터를 체크하는 작업이 필요하므로 잠금이 여러 테이블로 전파되고, 그로 인해 데드락이 발생할 때가 많다.
- 개발 시의 외래 키는 가이드 역할을 할 수 있다.
- `foreign_key_check` 시스템 변수를 OFF로 설정하면 외래 키 관계에 대한 체크 작업을 일시적으로 멈출 수 있다.
- OFF로 설정 후 특정 작업을 했다고 하더라도 일관성을 맞춰준 후 다시 외래 키 체크 기능을 활성화해야 한다.

### MVCC(Multi Version Concurrency Control)
- 레코드 레벨의 트랜잭션을 지원하는 DBMS가 제공하는 기능
- MVCC의 가장 큰 목적은 잠금을 사용하지 않는 일관된 읽기를 제공하는 것
- InnoDB는 Undo log를 이용해 이 기능을 구현
- Multi Version이 의미하는 바는, 하나의 레코드에 대해 여러 개의 버전이 동시에 관리되는 것
- isolation level이 READ UNCOMMITTED 인 경우를 제외하고 모두 Undo log에서 조회

#### Isolation level
동시에 여러 트랜잭션이 처리될 때 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있도록 허용할지 말지를 결정하는 것
- READ UNCOMMITTED
  - 다른 트랜잭션의 commit이나 rollback 여부와 상관없이 다른 트랜잭션의 값을 읽음
  - 정합성에 문제가 많아 사용하지 않는 것을 권장
  - DIRTY READ 현상 발생 - 트랜잭션이 작업이 완료되지 않았는데도 다른 트랜잭션에서 볼 수 있게 되는 현상
- READ COMMITTED
  - 대부분의 RDB에서 사용
  - DIRTY READ 현상 미발생
  - Undo log의 데이터를 조회
  - (중간에 commit이 발생한 상황)하나의 트랜잭션내에서 똑같은 SELECT 쿼리를 실행했을 때는 항상 같은 결과를 가져와야 하는 REPEATABLE READ 정합성에 어긋남
  - 이러한 문제는 주로 입금, 출금 처리가 진행되는 금전적인 처리에서 주로 발생 - 데이터의 정합성은 깨지고, 버그는 찾기 어려워짐
- REPEATABLE READ
  - 트랜잭션마다 트랜잭션 ID를 부여하여 자신의 트랜잭션 ID 보다 작은 트랜잭션 번호에서 변경한 것만 조회
  - PHANTOM READ 발생 - 다른 트랜잭션에서 수행한 변경 작업에 의해 레코드가 보였다가 안 보였다가 하는 현상, 이를 방지하기 위해서는 쓰기 잠금 필요.
- SERIALIZABLE
  - 가장 단순한 격리 수준이지만 가장 엄격한 격리 수준 
  - 성능 측면에서는 동시 처리성능이 가장 낮다. 
  - PHANTOM READ가 발생하지 않음
  - 데이터베이스에서 거의 사용되지 않음

> 참고: https://nesoy.github.io/articles/2019-05/Database-Transaction-isolation

#### MySQL에서 Insert와 Update
1. insert
   - `INSERT INTO member (id, name, area) VALUES (12, '홍길동', '서울');`
   - InnoDB 버퍼 풀에 데이터 저장
   - 데이터 파일(디스크)에 데이터 저장
   - Undo log에 데이터 없음
2. update
   - `UPDATE member SET area='경기' WHERE id=12;`
   - InnoDB 버퍼 풀에 데이터 수정
   - 데이터 파일(디스크)에 데이터 수정됐다고 생각해도 무방(InnoDB가 ACID를 보장, 백그라운드 스레드가 적절한 시점에 처리)
   - Undo log 영역에 변경 전 데이터 저장
   - commit을 실행하면 지금의 상태를 영구적 데이터로 저장(Undo log 영역의 데이터가 바로 삭제되는 것은 아니고 필요로 하는 트랜잭션이 없을 때 삭제)
   - rollback을 실행하면 Undo log 영역에 저장된 이전 데이터를 InnoDB 버퍼 풀로 다시 복구하고 Undo log 영역의 데이터 삭제










