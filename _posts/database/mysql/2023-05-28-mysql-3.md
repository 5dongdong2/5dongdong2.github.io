---
layout: post
title: Real MySQL 8.0 (3) - 아키텍처
date: 2023-05-28
categories: [database, mysql]
tags: [database, mysql]
---
# Real MySQL 8.0 8.0 (3) - 아키텍처
- MySQL 서버는 사람의 머리 역할의 MySQL 엔진과 손발 역할의 스토리지 엔진으로 구분
- 스토리지 엔진의 경우 핸들러 API를 만족하면 누구든지 스토리지 엔진을 구현해 MySQL 서버에 추가해서 사용 가능
- 기본제공되는 스토리지 엔진
  - InnoDB
  - MyISAM

***
## MySQL 엔진 아키텍처
MySQL 서버는 다른 DBMS에 비해 구조가 독특해 다른 DBMS에는 없는 혜택을 누릴 수 있으며, 반대로 다른 DBMS에서는 문제되지 않을 것들이 문제될 때가 있다. 크게 MySQL 엔진과 스토리지 엔진으로 구분한다

### MySQL 엔진
- 커넥션 핸들러
- SQL 인터페이스
- SQL 파서, 전처리기
- SQL 옵티마이저
- 캐시 & 버퍼

### 스토리지 엔진
- InnoDB or MyISAM
- Memory

실제 데이터를 디스크 스토리지에 저장하거나 읽어오는 부분을 전담

MySQL 서버에 MySQL 엔진은 하나지만, 스토리지 엔진은 여러 개를 동시에 사용 가능
```mysql
CREATE TABLE table_name (col1 INT, col2 INT) ENGINE=INNODB;
```
위와 같이 지정하면 SELECT, INSERT, DELETE, UPDATE 등의 작업 시 InnoDB 스토리지 엔진이 처리를 담당

각 스토리지 엔진은 성능 향상을 위해 키 캐시(MyISAM)나 InnoDB 버퍼 풀(InnoDB) 같은 기능을 내장

### 핸들러 API
- 핸들러(Handler) 요청에 사용되는 API
- 핸들러 요청
  - MySQL 엔진이 쿼리 실행기에서 데이터를 쓰거나 읽을 떄, 각 스토리지 엔진에 쓰기 또는 읽기를 요청하는 것
- InnoDB 스토리지 엔진도 핸들러 API를 사용해 MySQL 엔진과 데이터를 주고 받는다.
- 핸들러 API를 통해 얼마나 많은 데이터(레코드) 작업이 있는 지 확인
  - `SHOW GLOBAL STATUS LIKE 'Handler%';`

### MySQL 스레딩 구조
- MySQL 서버는 프로세스 기반이 아닌 스레드 기반
- 크게 Foreground thread와 Background thread로 구분
- `performance_schema.threads table`
<img src="performance_schema.threads.png">
- `thread/sql/one_connection` 스레드만 실제 사용자의 요청을 처리하는 Foreground threads
- background threads의 개수는 MySQL 서버 설정에 따라 달라질 수 있다.
- 동일한 이름의 스레드가 2개 이상씩 보이는 것은 MySQL 서버의 설정 내용에 의해 여러 스레드가 동일 작업을 병렬로 처리하는 경우
- MySQL의 커뮤니티 에디션
  - 전통적인 스레드 모델 사용 가능 
- MySQL의 엔터프라이즈 에디션과 Percona MySQL
  - 전통적인 스레드 모델 사용 가능
  - 스레드 풀(thead pool) 모델 사용 가능
- 전통적인 스레드 모델과 스레드 풀의 가장 큰 차이점은 Foreground thread와 connection의 관계
  - 전통적인 스레드 모델: Foreground thread와 connection이 1대1 관계(connection 별로 Foreground thread 생성)
  - 스레드 풀 모델: 하나의 스레드가 여러 개의 커넥션 요청을 전담

#### Foreground thread(client thread)
- Foreground thread의 최소 개수는 MySQL 서버에 접속된 클라이언트의 수
- 주로 각 클라이언트가 요청하는 쿼리 문장을 처리
- 클라이언트가 작업을 마치고 커넥션을 종료하면 담당 스레드는 스레드 캐시(thread cache)로 되돌아감
- 스레드 캐시에 일정 개수 이상의 대기 스레드가 있으면 스레드 캐시에 넣지 않고 스레드를 종료
- 스레드 캐시에 유지할 수 있는 최대 스레드 수: `thread_cache_size` 시스템 변수
- read
  1. 데이터를 MySQL 데이터 버퍼나 캐시에서 조회
  2. 없으면 디스크의 데이터나 인덱스 파일로부터 조회
- write
  - MyISAM의 경우, 디스크 쓰기 작업까지 Foreground thread가 처리
  - InnoDB의 경우, 데이터 버퍼나 캐시까지만 Foreground thread가 처리 / 버퍼부터 디스크까지는 Background thread가 처리

#### Background thread
보통은 InnoDB의 Background thread가 진행하는 작업
- 인서트 버퍼를 병합하는 스레드
- 로그를 디스크로 기록하는 스레드
- InnoDB 버퍼 풀의 데이터를 디스크에 기록하는 스레드
- 데이터를 버퍼로 읽어오는 스레드
- 잠금이나 데드락을 모니터링하는 스레드

5.5부터 데이터 쓰기 스레드와 읽기 스레드의 개수를 2개 이상 지정 가능(시스템 변수)
- `innodb_write_io_threads`
- `innodb_read_io_threads`
- InnoDB도 데이터 read는 주로 foreground thread에서 처리하기 때문에, read thread를 많이 설정할 필요 없다.
- write thread는 아주 많은 작업을 백그라운드로 처리하기 때문에, 일반적으로 내장 디스크를 사용할 때는 2~4 정도 설정(스토리지에 따라 최적화 필요)

**버퍼링**
- 쓰기 작업은 지연(버퍼링)되어 처리 가능
- 읽기 작업은 지연 불가능
- InnoDB는 쓰기작업을 버퍼링해서 일괄 처리
  - INSERT, UPDATE, DELETE 시, 데이터가 디스크의 파일로 완전히 저장될 때까지 기다리지 않아도 된다.
- MyISAM은 client thread가 쓰기까지 처리
  - 쓰기 버퍼링 사용 불가

### 메모리 할당 및 사용 구조
- 운영체제의 복잡한 할당 방식으로 할당
- 단순하게 MySQL의 시스템 변수로 설정해둔 만큼 할당 받는다고 생각
- MySQL 서버
  - 글로벌 메모리 영역
    - 클라이언트의 수와는 무관
    - 필요에 따라 N개 할당 가능(일반적으로 1개)
    - N개더라도 모든 스레드에 의해 공유
    - 종류
      - InnoDB 버퍼 풀
      - MyISAM 키 캐시
      - 바이너리 로그 버퍼
      - 리두 로그 버퍼
      - 테이블 캐시
  - 세션(커넥션, 로컬) 메모리 영역
    - 클라이언트 스레드가 쿼리를 처리하는 데 사용하는 메모리 영역
    - 커넥션당 생성되는 스레드가 사용하는 영역
    - 스레드간 독립적, 비공유
    - 커넥션이 열려있는 동안 계속 할당되어 있는 공간(커넥션 버퍼, 결과 버퍼)
    - 쿼리를 실행하는 순간에만 할당했다가 다시 해제하는 공간(소트 버퍼, 조인 버퍼)
      - 조인 버퍼
      - 정렬(sort) 버퍼
      - 네트워크 버퍼
      - 리드 버퍼

### 플러그인 스토리지 엔진 모델
- 스토리지 엔진, 사용자 인증 등
- `SHOW ENGINES;`, `SHOW PLUGINS` 명령어로 확인 가능

**MySQL에서 쿼리가 실행되는 과정**
    
MySQL 엔진(SQL parser -> SQL Optimizer -> SQL executor) -> <br>
스토리지 엔진(데이터 읽기/쓰기) -> <br>
디스크

=> 실질적인 `GROUP BY`나 `ORDER BY`는 MySQL 엔진의 처리 영역인 쿼리 실행기에서 처리

**핸들러**
MySQL 엔진이 스토리지 엔진에게 명령하려면 핸들러를 통해야만 한다.

### 컴포넌트
- 기존의 플러그인 아키텍처를 대체하기 위해 8.0부터 지원되는 컴포넌트 아키텍처
- 비밀번호 검증 기능은 5.7까지는 플러그인으로 지원되고, 8.0부터는 컴포넌트로 개선

**플러그인의 단점**
- 플러그인은 오직 MySQL 서버와 인터페이스 가능(플러그인간 통신 불가능)
- 플러그인은 MySQL 서버의 변수나 함수를 직접 호출(캡슐화x, 안전하지 않음)
- 플러그인은 상호 의존 관계를 설정할 수 없어 초기화가 어려움

### 쿼리 실행 구조

#### 쿼리 파서
- 요청으로 들어온 쿼리 문장을 토큰(MySQL이 인식할 수 있는 최소 단위나 어휘)으로 분리하고 트리 구조로 생성
- 기본 문법 오류 검출 및 오료 메시지 전달

#### 전처리기
- 파서 트리를 기반으로 구조적 문제점 확인
- 테이블 이름, 컬럼 이름, 내장 함수와 같은 개체를 매핑
- 해당 객체의 존재 여부와 접근 권한 확인

#### 옵티마이저
- DBMS의 두뇌
- 사용자 요청으로 들어온 쿼리 분장을 저렴한 비용으로 빠르게 처리할 지 결정

#### 실행 엔진
- 핸들러와 함께 손과 발 역할
- 옵티마이저가 결정한 내용을 핸들러들에게 명령(중간 관리자급)

#### 핸들러(스토리지 엔진)
- 실행 엔진의 요청에 따라 데이터를 디스크로 저장, 디스크로부터 읽어 오는 역할
- 스토리지 엔진을 의미

### 복제
나중에 다룸

### 쿼리 캐시
- 8.0부터 사라짐
- SQL 실행 결과를 메모리에 캐시, 동일 SQL이 실행되면 테이블을 읽지 않고 즉시 결과 반환
- 데이터가 변경되면 관련된 캐시는 전부 삭제 필요
- 심각한 동시 처리 성능 저하 유발
- 데이터가 변경이 거의 없는 서비스에서는 좋겠지만 그런 경우는 거의 없다.

### 스레드 풀
- 엔터프라이즈 버전에서 지원
- 커뮤니티 버전에서 사용하기 위해서는 Percona Server에서 제공하는 스레드 풀 사용

### 트랜잭션 지원 메타데이터
- 5.7까지는 테이블의 구조는 FRM 파일, 스토어드 프로그램은 (.TRN, .TRG .PAR ...) 파일에 저장
  - 파일 기반의 메타데이터는 트랜잭션을 지원하지 않기 때문에 MySQL 서버의 비정상적 종료가 발생하면 일관되지 않는 상태로 남게 됨(데이터베이스나 테이블이 깨졌다고 표현) 
- 8.0부터는 InnoDB 테이블에 저장(시스템 테이블)
  - 데이터 딕셔너리 정보들은 모두 mysql DB에 저장(mysql.ibd)
  - 디렉토리에 존재하는 위 파일은 특별히 조심
  - mysql table은 접근 권한이 없어 볼 수 없다.(실제로는 존재)
  - `information_schema`를 보면 데이터 딕셔너리에 대한 정보를 얻을 수 있다.
    - `SHOW CREATE TABLE INFORMATION_SCHEMA.TABLES;`
    - 뷰로 생성되어 있고, 이 뷰는 mysql db를 참조하고 있다.
  - MySQL 서버의 비정상 종료에도 완전한 성공 또는 완전한 실패로 정리
  - MyISAM이나 CSV 같은 스토리지 엔진은 여전히 메타 정보를 파일로 저장해야 한다.
  - 기존의 FRM 파일과 동일한 역할의 .sdi 파일이 존재
**데이터 딕셔너리 또는 메타데이터**
- 테이블의 구조 정보와 스토어드 프로그램 등의 정보

***
## InnoDB 스토리지 엔진 아키텍처
- MySQL에서 사용할 수 있는 스토리지 엔진 중 거의 유일하게 레코드 기반의 잠금을 제공
- 따라서 높은 동시성 처리가 가능하고 안정적이며 성능이 훌륭

### 프라이머리 키에 의한 클러스터링
- primary key를 기눚으로 클러스터링되어 저장
- 키 값의 순서대로 디스크에 저장
- secondary index는 레코드의 주소가 아닌 primary key를 논리적 주소로 사용
- primary key를 이용한 range scan은 상당히 빠르기 때문에, 쿼리의 실행 계획에서 primary key는 다른 보조 인덱스에 비해 비중이 높게 설정
- oracle의 IOT(Index Organized Table)와 동일한 구조가 InnoDB의 일반적인 테이블 구조

#### vs MyISAM
- MyISAM은 클러스터링 키 미지원
- MyISAM은 primary key와 secondary index가 구조적으로 같다. primary key는 unique 제약을 가진 secondary index
- MyISAM 테이블의 모든 인덱스는 물리적인 레코드의 주소 값(ROWID)을 가진다.

### 외래 키 지원
- InnoDB 스토리지 엔진 레벨에서 지원하는 기능으로 MyISAM 이나 MEMORY 테이블에서는 사용 불가
- InnoDB에서 외래 키는 부모 테이블과 자식 테이블 모두 해당 칼럼에 인덱스 생성이 필요
- 변경 시에는 반드시 부모-자식 데이터를 체크하는 작업이 필요하므로 잠금이 여러 테이블로 전파되고, 그로 인해 데드락이 발생할 때가 많다.
- 개발 시의 외래 키는 가이드 역할을 할 수 있다.
- `foreign_key_check` 시스템 변수를 OFF로 설정하면 외래 키 관계에 대한 체크 작업을 일시적으로 멈출 수 있다.
- OFF로 설정 후 특정 작업을 했다고 하더라도 일관성을 맞춰준 후 다시 외래 키 체크 기능을 활성화해야 한다.

### MVCC(Multi Version Concurrency Control)
- 레코드 레벨의 트랜잭션을 지원하는 DBMS가 제공하는 기능
- MVCC의 가장 큰 목적은 잠금을 사용하지 않는 일관된 읽기를 제공하는 것
- InnoDB는 Undo log를 이용해 이 기능을 구현
- Multi Version이 의미하는 바는, 하나의 레코드에 대해 여러 개의 버전이 동시에 관리되는 것
- isolation level이 READ UNCOMMITTED 인 경우를 제외하고 모두 Undo log에서 조회

#### Isolation level
동시에 여러 트랜잭션이 처리될 때 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있도록 허용할지 말지를 결정하는 것
- READ UNCOMMITTED
  - 다른 트랜잭션의 commit이나 rollback 여부와 상관없이 다른 트랜잭션의 값을 읽음
  - 정합성에 문제가 많아 사용하지 않는 것을 권장
  - DIRTY READ 현상 발생 - 트랜잭션이 작업이 완료되지 않았는데도 다른 트랜잭션에서 볼 수 있게 되는 현상
- READ COMMITTED
  - 대부분의 RDB에서 사용
  - DIRTY READ 현상 미발생
  - Undo log의 데이터를 조회
  - (중간에 commit이 발생한 상황)하나의 트랜잭션내에서 똑같은 SELECT 쿼리를 실행했을 때는 항상 같은 결과를 가져와야 하는 REPEATABLE READ 정합성에 어긋남
  - 이러한 문제는 주로 입금, 출금 처리가 진행되는 금전적인 처리에서 주로 발생 - 데이터의 정합성은 깨지고, 버그는 찾기 어려워짐
- REPEATABLE READ
  - 트랜잭션마다 트랜잭션 ID를 부여하여 자신의 트랜잭션 ID 보다 작은 트랜잭션 번호에서 변경한 것만 조회
  - PHANTOM READ 발생 - 다른 트랜잭션에서 수행한 변경 작업에 의해 레코드가 보였다가 안 보였다가 하는 현상, 이를 방지하기 위해서는 쓰기 잠금 필요.
- SERIALIZABLE
  - 가장 단순한 격리 수준이지만 가장 엄격한 격리 수준 
  - 성능 측면에서는 동시 처리성능이 가장 낮다. 
  - PHANTOM READ가 발생하지 않음
  - 데이터베이스에서 거의 사용되지 않음

> 참고: https://nesoy.github.io/articles/2019-05/Database-Transaction-isolation

#### MySQL에서 Insert와 Update
1. insert
   - `INSERT INTO member (id, name, area) VALUES (12, '홍길동', '서울');`
   - InnoDB 버퍼 풀에 데이터 저장
   - 데이터 파일(디스크)에 데이터 저장
   - Undo log에 데이터 없음
2. update
   - `UPDATE member SET area='경기' WHERE id=12;`
   - InnoDB 버퍼 풀에 데이터 수정
   - 데이터 파일(디스크)에 데이터 수정됐다고 생각해도 무방(InnoDB가 ACID를 보장, 백그라운드 스레드가 적절한 시점에 처리)
   - Undo log 영역에 변경 전 데이터 저장
   - commit을 실행하면 지금의 상태를 영구적 데이터로 저장(Undo log 영역의 데이터가 바로 삭제되는 것은 아니고 필요로 하는 트랜잭션이 없을 때 삭제)
   - rollback을 실행하면 Undo log 영역에 저장된 이전 데이터를 InnoDB 버퍼 풀로 다시 복구하고 Undo log 영역의 데이터 삭제

### 잠금 없는 일관된 읽기(Non-Locking Consistent Read)
- InnoDB는 MVCC 기술을 이용해 잠금을 걸지 않고 읽기 작업을 수행
- isolation level serializable을 제외하고 insert와 연결되지 않은 순수한 select 작업은 다른 트랜잭션의 변경 작업과 관계없이 항상 잠금 대기 없이 실행
- Undo log를 활용해 구현
- 오랜 시간 동안 활성 상태인 트랜잭션이 있는 경우, 계속해서 유지되는 Undo log로 인해 MySQL 서버가 느려질 수 있기 때문에 트랜잭션이 시작됐다면 가능한 빨리 롤백이나 커밋을 통해 트랜잭션을 완료하는 것이 좋다.

### 자동 데드락 감지
- InnoDB는 내부적으로 잠금이 데드락에 빠지지 않았는지 체크하기 위해 잠금 대기 목록을 그래프(Wait-for List) 형태로 관리
- 데드락 감지 스레드가 주기적으로 잠금 대기 그래프를 검사해 교착 상태에 빠진 트랜잭션들을 찾아서 그중 하나를 강제 종료
- Undo log의 양이 적은 트랜잭션이 먼저 강제종료
- 상위 레이어인 MySQL 엔진에서 관리되는 테이블 잠금(LOCK TABLES) 명령으로 잠긴 테이블의 경우 InnoDB 스토리지 엔진이 볼 수 없어 데드락 감지가 불확실할 수 있지만, `innodb_table_locks` 시스템 변수를 활성화하면 테이블 레벨의 잠금까지 감지 가능, 특별한 이유가 없다면 활성화
- 동시 처리 스레드가 많거나, 트랜잭션의 잠금 개수가 많아지면 데드락 감지 스레드가 느려진다.(데드락 감지를 위해 잠금 목록이 저장된 리스트에 새로운 잠금을 걸고 데드락 확인) 더 많은 CPU 자원 소모
- `innodb_deadlock_detect` 시스템 변수로 데드락 감지 스레드 작동 유무 설정
- `innodb_lock_wait_timeout` 시스템 변수를 활성화하면, 설정된 시간 이상동안 잠금이 유지되는 경우 에러 메시지를 반환

### 자동화된 장애 복구
- InnoDB는 데이터 파일이 손상되거나 MySQL 서버가 시작되지 못하는 경우가 거의 없다. 하지만 MySQL 서버와 무관하게 디스크나 서버 하드웨어 이슈로 스토리지 엔진이 자동 복구하지 못하는 경우가 발생할 수 있다. 이 경우 복구가 쉽지 않다.
- InnoDB의 데이터 파일은 기본적으로 MySQL 서버가 시작될 떄 자동 복구를 수행하는데, 자동으로 복구될 수 없는 손상이 있다면 자동 복구를 멈추고 MySQL 서버를 종료
- 자동 복구가 불가능한 경우, `innodb_force_recovery` 시스템 변수를 설정해 MySQL 서버를 실행
  - 로그 파일의 손상: 6
  - 데이터 파일의 손상: 1
  - 원인을 알 수 없는 손상: 1부터 6까지 변경하며 재시작(숫자가 커질수록 심각한 상황, 0이 아니면 복구모드, 복구모드에서는 SELECT 이외의 INSERT UPDATE DELETE 불가)
- MySQL 서버가 기동되고 InnoDB 테이블이 인식된다면 `mysqldump`를 이용해 데이터를 가능한 만큼 백업 후, 다시 DB와 테이블 생성하는 것이 좋다.
- MySQL 서버가 장애나 정상적으로 종료되는 시점에 진행 중인 트랜잭션이 있으면, MySQL은 그냥 단순히 그 커넥션을 강제로 끊어 버리고 별도의 정리 작업 없이 종료
- MySQL이 다시 시작하면 InnoDB 엔진은 Undo record를 이용해 데이터 페이지를 복구하고, redo log를 적용해 종료 시점이나 장애 발생 시점의 상태를 재현, 커밋되지 않은 트랜잭션은 모두 롤백

<table>
<thead>
  <tr>
    <th>innodb_force_recovery</th>
    <th>name</th>
    <th>description</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td>1</td>
    <td>SRV_FORCE_IGNORE_CORRUPT</td>
    <td>- 테이블스페이스의 데이터나 인덱스 페이지에서 손상된 부분을 무시하고 서버 재시작<br>- 에러 로그 파일에 Database page corruption on disk or a failed 이 있으면 대부분 이 경우<br>- DB를 재구축하는 것이 좋다.</td>
  </tr>
  <tr>
    <td>2</td>
    <td>SRV_FORCE_NO_BACKGROUND</td>
    <td>- 백그라운드 스레드 중 메인 스레드를 시작하지 않고 서버 기동<br>- 메인 스레드에 의해 주기적인 Undo log를 삭제(Undo purge)하는 과정에서 장애</td>
  </tr>
  <tr>
    <td>3</td>
    <td>SRV_FORCE_NO_TRX_UNDO</td>
    <td>- 커밋되지 않은 트랜잭션의 작업을 롤백하지 않고 그대로 놔둔 상태로 MySQL 서버를 기동하는 모드<br>- mysqldump를 통해 DB를 재구축 하는 것이 좋다.</td>
  </tr>
  <tr>
    <td>4</td>
    <td>SRV_FORCE_NO_IBUF_MERGE</td>
    <td>- 인서트 버퍼의 손상을 감지해 서버 시작이 불가할 떄 사용<br>- 스토리지 엔진이 인서트 버퍼의 내용을 무시하고 강제로 서버 실행<br>- 인서트 버퍼는 실제 데이터가 아닌 인덱스에 관련된 부분이므로 테이블을 덤프한 후 다시 구축하면 데이터 손상 없이 복구 가능</td>
  </tr>
  <tr>
    <td>5</td>
    <td>SRV_FORCE_NO_UNDU_LOG_SCAN</td>
    <td>- Undo log를 사용할 수 없는 경우 사용<br>- Undo log를 무시하고 서버를 실행<br>- 서버가 종료되던 시점에 커밋되지 않았던 작업도 모두 커밋된 것처럼 처리<br>- 잘못된 데이터가 데이터베이스에 남는 복구 모드<br>- DB를 재구축하는 것이 좋다.</td>
  </tr>
  <tr>
    <td>6</td>
    <td>SRV_FORCE_NO_LOG_REDO</td>
    <td>- Redo log를 사용할 수 없는 경우 사용<br>- Redo log를 무시하고 서버를 실행<br>- 커밋이 됐다고 해도 Redo log에만 기록되고 데이터 파일에 기록되지 않은 데이터는 모두 무시<br>- 마지막 체크포인트(백그라운드 스레드에 의해 데이터 파일에 변경사항을 적용) 시점의 데이터만 존재<br>- DB를 재구축하는 것이 좋다.</td>
  </tr>
</tbody>
</table>

- 1~6까지 시도가 실패하면 백업을 이용해 다시 구축하는 방법밖에 없다.
- 백업이 있다면 마지막 백업으로 다시 DB 구축, 바이너리 로그를 사용해 최대한 장애 시점까지 데이터 복구 가능
- 마지막 풀 백업 시점부터 장애 시점까지 바이너리 로그가 있다면 복구 모드를 이용하는 것보다 바이너리 로그를 복구하는 것이 데이터 손실이 적을 수 있다.

### InnoDB 버퍼 풀
- InnoDB의 가장 핵심
- 디스크의 데이터 파일이나 인덱스 정보를 메모리에 캐시해 두는 공간
- 쓰기 작업(CUD)을 지연시켜 일괄 작업으로 처리할 수 있게하는 버퍼 역할

#### 버퍼 풀의 크기 설정
#### 버퍼 풀의 구조
#### 버퍼 풀과 리두 로그
#### 버퍼 풀 플러시(Buffer Pool Flush)
1. 플러시 리스트 플러시
2. LRU 리스트 플러시
#### 버퍼 풀 상태 백업 및 복구
#### 버퍼 풀의 적재 내용 확인


