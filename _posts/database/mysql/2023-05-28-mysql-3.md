---
layout: post
title: Real MySQL 8.0 (3) - 아키텍처
date: 2023-05-28
categories: [database, mysql]
tags: [database, mysql]
---
# Real MySQL 8.0 8.0 (3) - 아키텍처
- MySQL 서버는 사람의 머리 역할의 MySQL 엔진과 손발 역할의 스토리지 엔진으로 구분
- 스토리지 엔진의 경우 핸들러 API를 만족하면 누구든지 스토리지 엔진을 구현해 MySQL 서버에 추가해서 사용 가능
- 기본제공되는 스토리지 엔진
  - InnoDB
  - MyISAM

***
## MySQL 엔진 아키텍처
MySQL 서버는 다른 DBMS에 비해 구조가 독특해 다른 DBMS에는 없는 혜택을 누릴 수 있으며, 반대로 다른 DBMS에서는 문제되지 않을 것들이 문제될 때가 있다. 크게 MySQL 엔진과 스토리지 엔진으로 구분한다

### MySQL 엔진
- 커넥션 핸들러
- SQL 인터페이스
- SQL 파서, 전처리기
- SQL 옵티마이저
- 캐시 & 버퍼

### 스토리지 엔진
- InnoDB or MyISAM
- Memory

실제 데이터를 디스크 스토리지에 저장하거나 읽어오는 부분을 전담

MySQL 서버에 MySQL 엔진은 하나지만, 스토리지 엔진은 여러 개를 동시에 사용 가능
```mysql
CREATE TABLE table_name (col1 INT, col2 INT) ENGINE=INNODB;
```
위와 같이 지정하면 SELECT, INSERT, DELETE, UPDATE 등의 작업 시 InnoDB 스토리지 엔진이 처리를 담당

각 스토리지 엔진은 성능 향상을 위해 키 캐시(MyISAM)나 InnoDB 버퍼 풀(InnoDB) 같은 기능을 내장

### 핸들러 API
- 핸들러(Handler) 요청에 사용되는 API
- 핸들러 요청
  - MySQL 엔진이 쿼리 실행기에서 데이터를 쓰거나 읽을 떄, 각 스토리지 엔진에 쓰기 또는 읽기를 요청하는 것
- InnoDB 스토리지 엔진도 핸들러 API를 사용해 MySQL 엔진과 데이터를 주고 받는다.
- 핸들러 API를 통해 얼마나 많은 데이터(레코드) 작업이 있는 지 확인
  - `SHOW GLOBAL STATUS LIKE 'Handler%';`

### MySQL 스레딩 구조
- MySQL 서버는 프로세스 기반이 아닌 스레드 기반
- 크게 Foreground thread와 Background thread로 구분
- `performance_schema.threads table`
<img src="performance_schema.threads.png">
- `thread/sql/one_connection` 스레드만 실제 사용자의 요청을 처리하는 Foreground threads
- background threads의 개수는 MySQL 서버 설정에 따라 달라질 수 있다.
- 동일한 이름의 스레드가 2개 이상씩 보이는 것은 MySQL 서버의 설정 내용에 의해 여러 스레드가 동일 작업을 병렬로 처리하는 경우
- MySQL의 커뮤니티 에디션
  - 전통적인 스레드 모델 사용 가능 
- MySQL의 엔터프라이즈 에디션과 Percona MySQL
  - 전통적인 스레드 모델 사용 가능
  - 스레드 풀(thead pool) 모델 사용 가능
- 전통적인 스레드 모델과 스레드 풀의 가장 큰 차이점은 Foreground thread와 connection의 관계
  - 전통적인 스레드 모델: Foreground thread와 connection이 1대1 관계(connection 별로 Foreground thread 생성)
  - 스레드 풀 모델: 하나의 스레드가 여러 개의 커넥션 요청을 전담

#### Foreground thread(client thread)
- Foreground thread의 최소 개수는 MySQL 서버에 접속된 클라이언트의 수
- 주로 각 클라이언트가 요청하는 쿼리 문장을 처리
- 클라이언트가 작업을 마치고 커넥션을 종료하면 담당 스레드는 스레드 캐시(thread cache)로 되돌아감
- 스레드 캐시에 일정 개수 이상의 대기 스레드가 있으면 스레드 캐시에 넣지 않고 스레드를 종료
- 스레드 캐시에 유지할 수 있는 최대 스레드 수: `thread_cache_size` 시스템 변수
- read
  1. 데이터를 MySQL 데이터 버퍼나 캐시에서 조회
  2. 없으면 디스크의 데이터나 인덱스 파일로부터 조회
- write
  - MyISAM의 경우, 디스크 쓰기 작업까지 Foreground thread가 처리
  - InnoDB의 경우, 데이터 버퍼나 캐시까지만 Foreground thread가 처리 / 버퍼부터 디스크까지는 Background thread가 처리

#### Background thread
보통은 InnoDB의 Background thread가 진행하는 작업
- 인서트 버퍼를 병합하는 스레드
- 로그를 디스크로 기록하는 스레드
- InnoDB 버퍼 풀의 데이터를 디스크에 기록하는 스레드
- 데이터를 버퍼로 읽어오는 스레드
- 잠금이나 데드락을 모니터링하는 스레드

5.5부터 데이터 쓰기 스레드와 읽기 스레드의 개수를 2개 이상 지정 가능(시스템 변수)
- `innodb_write_io_threads`
- `innodb_read_io_threads`
- InnoDB도 데이터 read는 주로 foreground thread에서 처리하기 때문에, read thread를 많이 설정할 필요 없다.
- write thread는 아주 많은 작업을 백그라운드로 처리하기 때문에, 일반적으로 내장 디스크를 사용할 때는 2~4 정도 설정(스토리지에 따라 최적화 필요)

**버퍼링**
- 쓰기 작업은 지연(버퍼링)되어 처리 가능
- 읽기 작업은 지연 불가능
- InnoDB는 쓰기작업을 버퍼링해서 일괄 처리
  - INSERT, UPDATE, DELETE 시, 데이터가 디스크의 파일로 완전히 저장될 때까지 기다리지 않아도 된다.
- MyISAM은 client thread가 쓰기까지 처리
  - 쓰기 버퍼링 사용 불가

### 메모리 할당 및 사용 구조
- 운영체제의 복잡한 할당 방식으로 할당
- 단순하게 MySQL의 시스템 변수로 설정해둔 만큼 할당 받는다고 생각
- MySQL 서버
  - 글로벌 메모리 영역
    - 클라이언트의 수와는 무관
    - 필요에 따라 N개 할당 가능(일반적으로 1개)
    - N개더라도 모든 스레드에 의해 공유
    - 종류
      - InnoDB 버퍼 풀
      - MyISAM 키 캐시
      - 바이너리 로그 버퍼
      - 리두 로그 버퍼
      - 테이블 캐시
  - 세션(커넥션, 로컬) 메모리 영역
    - 클라이언트 스레드가 쿼리를 처리하는 데 사용하는 메모리 영역
    - 커넥션당 생성되는 스레드가 사용하는 영역
    - 스레드간 독립적, 비공유
    - 커넥션이 열려있는 동안 계속 할당되어 있는 공간(커넥션 버퍼, 결과 버퍼)
    - 쿼리를 실행하는 순간에만 할당했다가 다시 해제하는 공간(소트 버퍼, 조인 버퍼)
      - 조인 버퍼
      - 정렬(sort) 버퍼
      - 네트워크 버퍼
      - 리드 버퍼

### 플러그인 스토리지 엔진 모델
- 스토리지 엔진, 사용자 인증 등
- `SHOW ENGINES;`, `SHOW PLUGINS` 명령어로 확인 가능

**MySQL에서 쿼리가 실행되는 과정**
    
MySQL 엔진(SQL parser -> SQL Optimizer -> SQL executor) -> <br>
스토리지 엔진(데이터 읽기/쓰기) -> <br>
디스크

=> 실질적인 `GROUP BY`나 `ORDER BY`는 MySQL 엔진의 처리 영역인 쿼리 실행기에서 처리

**핸들러**
MySQL 엔진이 스토리지 엔진에게 명령하려면 핸들러를 통해야만 한다.

### 컴포넌트
- 기존의 플러그인 아키텍처를 대체하기 위해 8.0부터 지원되는 컴포넌트 아키텍처
- 비밀번호 검증 기능은 5.7까지는 플러그인으로 지원되고, 8.0부터는 컴포넌트로 개선

**플러그인의 단점**
- 플러그인은 오직 MySQL 서버와 인터페이스 가능(플러그인간 통신 불가능)
- 플러그인은 MySQL 서버의 변수나 함수를 직접 호출(캡슐화x, 안전하지 않음)
- 플러그인은 상호 의존 관계를 설정할 수 없어 초기화가 어려움

### 쿼리 실행 구조

#### 쿼리 파서
- 요청으로 들어온 쿼리 문장을 토큰(MySQL이 인식할 수 있는 최소 단위나 어휘)으로 분리하고 트리 구조로 생성
- 기본 문법 오류 검출 및 오료 메시지 전달

#### 전처리기
- 파서 트리를 기반으로 구조적 문제점 확인
- 테이블 이름, 컬럼 이름, 내장 함수와 같은 개체를 매핑
- 해당 객체의 존재 여부와 접근 권한 확인

#### 옵티마이저
- DBMS의 두뇌
- 사용자 요청으로 들어온 쿼리 분장을 저렴한 비용으로 빠르게 처리할 지 결정

#### 실행 엔진
- 핸들러와 함께 손과 발 역할
- 옵티마이저가 결정한 내용을 핸들러들에게 명령(중간 관리자급)

#### 핸들러(스토리지 엔진)
- 실행 엔진의 요청에 따라 데이터를 디스크로 저장, 디스크로부터 읽어 오는 역할
- 스토리지 엔진을 의미

### 복제
나중에 다룸

### 쿼리 캐시
- 8.0부터 사라짐
- SQL 실행 결과를 메모리에 캐시, 동일 SQL이 실행되면 테이블을 읽지 않고 즉시 결과 반환
- 데이터가 변경되면 관련된 캐시는 전부 삭제 필요
- 심각한 동시 처리 성능 저하 유발
- 데이터가 변경이 거의 없는 서비스에서는 좋겠지만 그런 경우는 거의 없다.

### 스레드 풀
- 엔터프라이즈 버전에서 지원
- 커뮤니티 버전에서 사용하기 위해서는 Percona Server에서 제공하는 스레드 풀 사용

### 트랜잭션 지원 메타데이터
- 5.7까지는 테이블의 구조는 FRM 파일, 스토어드 프로그램은 (.TRN, .TRG .PAR ...) 파일에 저장
  - 파일 기반의 메타데이터는 트랜잭션을 지원하지 않기 때문에 MySQL 서버의 비정상적 종료가 발생하면 일관되지 않는 상태로 남게 됨(데이터베이스나 테이블이 깨졌다고 표현) 
- 8.0부터는 InnoDB 테이블에 저장(시스템 테이블)
  - 데이터 딕셔너리 정보들은 모두 mysql DB에 저장(mysql.ibd)
  - 디렉토리에 존재하는 위 파일은 특별히 조심
  - mysql table은 접근 권한이 없어 볼 수 없다.(실제로는 존재)
  - `information_schema`를 보면 데이터 딕셔너리에 대한 정보를 얻을 수 있다.
    - `SHOW CREATE TABLE INFORMATION_SCHEMA.TABLES;`
    - 뷰로 생성되어 있고, 이 뷰는 mysql db를 참조하고 있다.
  - MySQL 서버의 비정상 종료에도 완전한 성공 또는 완전한 실패로 정리
  - MyISAM이나 CSV 같은 스토리지 엔진은 여전히 메타 정보를 파일로 저장해야 한다.
  - 기존의 FRM 파일과 동일한 역할의 .sdi 파일이 존재
**데이터 딕셔너리 또는 메타데이터**
- 테이블의 구조 정보와 스토어드 프로그램 등의 정보
























